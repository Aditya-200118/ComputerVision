\documentclass[11pt, letterpaper]{article}

% --- Encoding & Margins ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{framed}

\geometry{margin=1in}

% --- Fonts ---
\usepackage{mathptmx} % Times New Roman
\usepackage[scaled]{helvet} 
\usepackage{courier}

% --- Graphics & Tables ---
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{booktabs}
\usepackage{array}

% --- Math ---
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

% --- Code Highlighting ---
\usepackage{listings}
\usepackage{xcolor}

\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    stringstyle=\color{red},
    commentstyle=\color{green!50!black},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=single,
    tabsize=4
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\colorlet{shadecolor}{orange!15}
\lstset{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=Python
}

% --- Links & Headers ---
\usepackage{hyperref}
\usepackage{fancyhdr}

\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}
\lhead{CSCI 8820: Assignment 1}
\renewcommand{\headrulewidth}{0.5pt}

% ============================================================
% DOCUMENT START
% ============================================================
\begin{document}

\begin{titlepage}
    \centering
    \vspace*{2in}
    {\huge \bfseries Assignment 1: Connected Component Labeling\par}
    \vspace{0.6in}
    {\Large Aditya Bhargava \par}
    {\large UGA ID: 811235738 \par}
    \vspace{0.6in}
    {\large CSCI 8820: Computer Vision and Pattern Recognition \par}
    {\large Department of Computer Science, University of Georgia \par}
    {\large February 12, 2026 \par}
\end{titlepage}

\newpage
\tableofcontents
\newpage

\section{Introduction and Preprocessing}
This report implements an iterative Connected Component Labeling (CCL) algorithm to segment and analyze objects in a grayscale image. The pipeline involves binary thresholding, labeling, and geometric feature extraction.

\subsection{Thresholding and Binary Mask Generation}
The input image $B$ was converted to a binary image $B_T$ using a fixed threshold $T=128$. To ensure consistency, the mask was automatically inverted by $B_{T} = 1-B_{T}$.

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{Image_B_Original.png}
        \caption{Original Grayscale Image ($B$)}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=\linewidth]{Image_BT_Binary.png}
        \caption{Thresholded Binary Image (with inversion) ($B_T$)}
    \end{subfigure}
    \caption{Preprocessing: Conversion from 8-bit grayscale to binary mask.}
\end{figure}

\section{Methodology}
\subsection{Connected Component Labeling (CCL)}
An iterative 4-connected CCL algorithm was implemented using a two-pass approach:
\begin{enumerate}
    \item \textbf{First Pass:} Raster-scanning the image and assigning temporary labels based on the 4 connectivity of the top and left neighbors. Collisions were managed via a union-find data structure.
    \item \textbf{Second Pass:} Resolution of equivalences to merge components and sequential re-labeling of the final IDs.
\end{enumerate}
% \newpage
\subsection{Feature Extraction and Mathematical Models}

Geometric properties were derived from the zeroth-, first-, and second-order central moments.

\begin{itemize}

\item \textbf{Area and Centroid:}  
The area and centroid coordinates of a binary object $B(i,j)$ are defined as

\begin{align}
A &= \sum_{i=1}^{n} \sum_{j=1}^{m} B(i, j), \\
X_c &= \frac{1}{A} \sum_{i=1}^{n} \sum_{j=1}^{m} j \, B(i,j), \\
Y_c &= \frac{1}{A} \sum_{i=1}^{n} \sum_{j=1}^{m} i \, B(i,j),
\end{align}

where $A$ denotes the object area, and $(X_c, Y_c)$ represents the centroid location.

\item \textbf{Orientation ($\theta$):}  
The principal axis orientation is obtained by minimizing the second central moment:

\begin{equation}
\theta = \frac{1}{2} \tan^{-1}\!\left( \frac{b}{a - c} \right),
\end{equation}

where $a$, $b$, and $c$ are second-order central moments.

\item \textbf{Second-Order Central Moments:}  
These moments are computed as

% \begin{shaded}
\begin{align}
a &= \sum_{i=1}^{n} \sum_{j=1}^{m} [X'(i,j)]^2 \, B(i,j), \\
b &= 2 \sum_{i=1}^{n} \sum_{j=1}^{m} X'(i,j) Y'(i,j) \, B(i,j), \\
c &= \sum_{i=1}^{n} \sum_{j=1}^{m} [Y'(i,j)]^2 \, B(i,j),
\end{align}
% \end{shaded}

where $X'(i,j) = j - X_c$ and $Y'(i,j) = i - Y_c$ denote centroid-shifted coordinates.

\item \textbf{Eccentricity:}  
The eccentricity of the object is computed from the eigenvalues of the covariance matrix:

\begin{equation}
\text{Eccentricity} = \sqrt{1 - \frac{I_{\min}}{I_{\max}}},
\end{equation}

where $I_{\max}$ and $I_{\min}$ are the major and minor principal moments, respectively.
\begin{shaded}
\textbf{\textit{Note:}} Consistency of the moment calculations was verified by checking that the invariant relation $\vert (a + c) - (I_{\max} + I_{\min}) \vert$ remained close to zero. With a maximum absolute error of 
$6.0 \times 10^{-8}$ across all tests.
\end{shaded}


\item \textbf{Compactness:}  
Compactness, a measure of shape circularity, is defined as

\begin{equation}
\text{Compactness} = \frac{P^2}{A},
\end{equation}

where $P$ is the perimeter and $A$ is the area.

\end{itemize}


\section{Experimental Results}
The algorithm was evaluated across three minimum size thresholds: 100, 500, and 1000 pixels.\\
\textbf{\textit{Note:}} Kindly correlate the Labeled Components with their respective Feature Tables: For Case 1 refer to Figure 2, and for Case 2 (Figure 3) and Case 3 (Figure 5) refer to Figure 4 and Figure 6 respectively.

\subsection{Case 1: Minimum Size Threshold = 100}
At $T_{size}=100$, the algorithm labels artifacts/noise in the image as components along with primary objects of interest as shown in Figure 2. 

\begin{figure}[H]
    \centering
    % Reduced width slightly to prevent page overflow
    \includegraphics[width=0.62\textwidth]{Image_C_Size_100.png}
    \vspace{0.1cm} 
    \includegraphics[width=0.85\textwidth]{Component_Description_Table_Size_100.pdf}
    \caption{Labeled Components and Corresponding Feature Table for Case 1}
\end{figure}
\newpage
\subsection{Case 2: Minimum Size Threshold = 500}
Increasing the threshold effectively filters out noise while correctly labelling the primary objects.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{Image_C_Size_500.png}
    \caption{Labeled Components ($Size \ge 500$).}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{Component_Description_Table_Size_500.pdf}
    \caption{Extracted Features for Case 2.}
\end{figure}
\newpage
\subsection{Case 3: Minimum Size Threshold = 1000}
At $T_{size}=1000$, only the most significant geometric structures remain.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{Image_C_Size_1000.png}
    \caption{Labeled Components ($Size \ge 1000$).}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{Component_Description_Table_Size_1000.pdf}
    \caption{Extracted Features for Case 3.}
\end{figure}
\newpage
\newpage
\section{Histogram Comparison}
The following histograms illustrate the distribution of labels across the image at different filtering stages. As the threshold increases, the removal of noise and smaller components is reflected in the simplification of the label frequency.

\begin{figure}[H]
    \centering
    % Histogram 1
    \begin{subfigure}[b]{0.75\textwidth}
        \centering
        \includegraphics[width=\linewidth]{Histograms_Size_100.png}
        \caption{Frequency of Labels ($Size \ge 100$)}
    \end{subfigure}
    
    \vspace{1em} % Add some vertical spacing
    
    % Histogram 2
    \begin{subfigure}[b]{0.75\textwidth}
        \centering
        \includegraphics[width=\linewidth]{Histograms_Size_500.png}
        \caption{Frequency of Labels ($Size \ge 500$)}
    \end{subfigure}
    
    \vspace{1em}
    
    % Histogram 3
    \begin{subfigure}[b]{0.75\textwidth}
        \centering
        \includegraphics[width=\linewidth]{Histograms_Size_1000.png}
        \caption{Frequency of Labels ($Size \ge 1000$)}
    \end{subfigure}
    
    \caption{Comparison of component label distributions at various size thresholds.}
    \label{fig:histograms_comparison}
\end{figure}
\newpage
\newpage
\section{Analysis}
\subsection{Component Descriptions}
The following components were identified and analyzed based on their geometric properties and attributes:

\begin{description}
    \item[Hammer:] The largest component in the scene with an area of 19,762 pixels. It exhibits an elongation of 5.54 and a distinct orientation of approximately -19.6$^\circ$.
    \item[Wrench:] A highly elongated tool-shaped object with an area of 15,327 pixels and a near-vertical orientation of 79.0$^\circ$.
    \item[Hexagon:] A compact geometric shape with the lowest eccentricity (0.388) among the primary objects, indicating a more equilateral structure.
    \item[Triangle:] A mid-sized geometric component with an area of 8,913 pixels and a relatively low elongation of 1.49.
    \item[Cyan Base:] A wide, horizontal structure spanning the bottom of the frame. It has the highest perimeter (1,200 pixels) and a very high elongation of 158.65 due to its thin, wide aspect ratio.
    \item[Orange Sliver (Noise):] A thin vertical artifact located at the top-right edge with an area of 620 pixels. It is removed when the size threshold is increased to 1000.
    \item[Small Fragment (Noise):] A tiny vertical sliver with an area of only 119 pixels, which is immediately filtered out at any threshold above 100.
\end{description}

\subsection{Noise Analysis and Size Filter Trade-off}
The experimental results highlight a fundamental trade-off:
\begin{itemize}
    \item \textbf{Lower Threshold (100 \& 500):} Small noise components are detected as objects.
    \item \textbf{High Threshold (1000):} Fine structural details may be lost if they do not meet the pixel count $(T_{size})$ requirement.
\end{itemize}

\subsection{Geometric Validation}
To ensure the accuracy of the moment-based orientation, the invariant property $I_{max} + I_{min} = a + c$ was calculated. The error was consistently negligible ($6.0\times10^{-8}$), validating the orientation calculation and axis visualization.

\section{Conclusion}
The iterative CCL algorithm effectively labelled the components in the test image. The 1000-pixel threshold successfully isolates the Wrench, Hammer, Hexagon, Triangle, and Base as the primary structural components.

\begin{shaded}
\textbf{\textit{Note:}} For source code kindly refer to appendix on next page
\end{shaded}

\newpage
\section{Appendix: Source Code}
The following Python script was used to perform all operations described in this report.

\begin{lstlisting}
# Paste your python code here. 
# It will be formatted automatically with syntax highlighting.
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from collections import defaultdict

plt.rcParams.update(
    {
        "font.family": "serif",
        "font.size": 10,
        "axes.titlesize": 12,
        "axes.labelsize": 10,
        "figure.dpi": 600,
    }
)


def load_and_preprocess(path):
    try:
        with open(path, "rb") as f:
            _ = f.read(512)
            img = np.fromfile(f, dtype=np.uint8)

        original = img.reshape((512, 512))
        binary = (original > 128).astype(np.uint8)

        binary = 1 - binary

        return original, binary
    except FileNotFoundError:
        print(f"Error: File {path} not found.")
        exit()


def label_components(binary_img):
    """Iterative CCL with 4-connectivity."""
    rows, cols = binary_img.shape
    labels = np.zeros((rows, cols), dtype=int)
    current_label = 1
    equivalences = defaultdict(set)

    # Pass 1 Raster Scan
    for i in range(rows):
        for j in range(cols):
            if binary_img[i, j] == 1:
                neighbors = []
                if i > 0 and labels[i - 1, j] > 0:
                    neighbors.append(labels[i - 1, j])
                if j > 0 and labels[i, j - 1] > 0:
                    neighbors.append(labels[i, j - 1])

                if not neighbors:
                    labels[i, j] = current_label
                    current_label += 1
                elif len(neighbors) == 1:
                    labels[i, j] = neighbors[0]
                else:
                    min_lab = min(neighbors)
                    labels[i, j] = min_lab
                    for lab in neighbors:
                        if lab != min_lab:
                            equivalences[min_lab].add(lab)
                            equivalences[lab].add(min_lab)

    # Resolve Equivalences
    label_map = {}
    visited = set()

    def dfs(node, root):
        stack = [node]
        while stack:
            n = stack.pop()
            if n not in visited:
                visited.add(n)
                label_map[n] = root
                stack.extend(equivalences[n])

    for i in range(1, current_label):
        if i not in visited:
            dfs(i, i)

    # Pass 2
    for i in range(rows):
        for j in range(cols):
            if labels[i, j] > 0:
                labels[i, j] = label_map.get(labels[i, j], labels[i, j])

    return labels


def generate_color_map(labels):
    unique_labels = np.unique(labels)
    unique_labels = unique_labels[unique_labels != 0]

    np.random.seed(29)
    color_map = {}
    for lab in unique_labels:
        color = np.random.rand(3)
        while np.mean(color) < 0.4:
            color = np.random.rand(3)
        color_map[lab] = color
    return color_map


def filter_and_relabel(labels, min_size):
    unique_labels, counts = np.unique(labels, return_counts=True)
    valid_mask = (unique_labels != 0) & (counts >= min_size)
    valid_labels = unique_labels[valid_mask]

    new_labels = np.zeros_like(labels)
    mapping = {}

    for new_id, old_id in enumerate(valid_labels, 1):
        new_labels[labels == old_id] = new_id
        mapping[new_id] = old_id

    return new_labels, mapping


def extract_features(labels):
    props = {}
    indices = np.unique(labels)
    indices = indices[indices != 0]

    for lab in indices:
        coords = np.argwhere(labels == lab)
        y, x = coords[:, 0], coords[:, 1]
        area = len(coords)

        xc, yc = np.mean(x), np.mean(y)
        min_x, max_x = np.min(x), np.max(x)
        min_y, max_y = np.min(y), np.max(y)

        x_prime = x - xc
        y_prime = y - yc

        a = np.sum(x_prime**2)
        b = 2 * np.sum(x_prime * y_prime)
        c = np.sum(y_prime**2)

        theta = 0.5 * np.arctan2(b, a - c)
        theta_deg = np.degrees(theta)

        term = np.sqrt((a - c) ** 2 + b**2)
        Imax = (a + c + term) / 2
        Imin = (a + c - term) / 2

        # Elongation Ratio
        elongation = (Imax / Imin) if Imin > 0 else 0

        # Moment Error Check
        moment_error = abs((a + c) - (Imax + Imin))
        eccentricity = np.sqrt(1 - (Imin / Imax)) if Imax > 0 else 0

        perimeter = 0
        rows_img, cols_img = labels.shape
        for py, px in coords:
            is_edge = py == 0 or py == rows_img - 1 or px == 0 or px == cols_img - 1
            if not is_edge:
                if (
                    labels[py - 1, px] != lab
                    or labels[py + 1, px] != lab
                    or labels[py, px - 1] != lab
                    or labels[py, px + 1] != lab
                ):
                    is_edge = True
            if is_edge:
                perimeter += 1

        compactness = (perimeter**2) / area

        props[lab] = {
            "area": area,
            "centroid": (xc, yc),
            "bbox": (min_x, min_y, max_x, max_y),
            "orientation": theta,
            "orientation_deg": theta_deg,
            "elongation": elongation,
            "eccentricity": eccentricity,
            "perimeter": perimeter,
            "compactness": compactness,
            "moment_error": moment_error,
        }
    return props


def save_component_description_table(props, size_thresh):

    if not props:
        return

    column_labels = [
        "ID",
        "Area",
        "Centroid",
        "Bounding Box",
        "Orient(deg)",
        "Elongation",
        "Eccentricity",
        "Perimeter",
        "Compactness",
    ]
    table_data = []

    for lab in sorted(props.keys()):
        p = props[lab]
        xc, yc = p["centroid"]
        min_x, min_y, max_x, max_y = p["bbox"]

        table_data.append(
            [
                lab,
                p["area"],
                f"({xc:.1f}, {yc:.1f})",
                f"[{min_x},{min_y},{max_x},{max_y}]",
                f"{p['orientation_deg']:.1f}",
                f"{p['elongation']:.2f}",
                f"{p['eccentricity']:.3f}",
                f"{p['perimeter']}",
                f"{p['compactness']:.2f}",
            ]
        )

    total_count = len(props)
    n_rows = len(table_data) + 1

    fig_height = max(2.5, (n_rows + 1) * 0.5)

    fig, (ax_main, ax_sum) = plt.subplots(
        2, 1, figsize=(11, fig_height), gridspec_kw={"height_ratios": [n_rows, 1]}
    )

    ax_main.axis("off")
    ax_sum.axis("off")

    main_table = ax_main.table(
        cellText=table_data,
        colLabels=column_labels,
        loc="center",
        cellLoc="center",
        colWidths=[0.05, 0.08, 0.15, 0.18, 0.12, 0.10, 0.15, 0.15, 0.15],
    )

    main_table.auto_set_font_size(False)
    main_table.set_fontsize(9)
    main_table.scale(1, 1.5)

    for (row, col), cell in main_table.get_celld().items():
        cell.set_edgecolor("black")
        cell.set_linewidth(0.5)
        if row == 0:
            cell.set_text_props(weight="bold")
            cell.set_facecolor("#eaeaea")
            cell.set_linewidth(1.0)
        else:
            cell.set_facecolor("white")

    summary_data = [["Total Components Labelled:", total_count]]

    sum_table = ax_sum.table(
        cellText=summary_data, loc="top", cellLoc="center", colWidths=[0.98, 0.15]
    )

    sum_table.auto_set_font_size(False)
    sum_table.set_fontsize(10)
    sum_table.scale(1, 1.5)

    for (row, col), cell in sum_table.get_celld().items():
        cell.set_edgecolor("black")
        cell.set_linewidth(1.0)
        cell.set_text_props(weight="bold")
        if col == 0:
            cell.set_text_props(ha="center")
            cell.set_facecolor("#f9f9f9")
        else:
            cell.set_text_props(ha="center")
            cell.set_facecolor("white")

    plt.suptitle(
        f"Component Description Table (Size >= {size_thresh})"
        fontsize=12,
        fontweight="bold",
        y=0.95,
    )

    outfile = f"Component_Description_Table_Size_{size_thresh}.pdf"
    plt.savefig(outfile, format="pdf", dpi=600, bbox_inches="tight")
    plt.close()
    print(f"[Saved PDF] {outfile}")


def visualize_results(labels, props, size_thresh, global_colors, mapping):
    fig, ax = plt.subplots(figsize=(10, 10))

    colored = np.zeros((*labels.shape, 3))
    colored[:] = [0, 0, 0]

    for lab in props.keys():
        original_id = mapping[lab]
        colored[labels == lab] = global_colors[original_id]

    ax.imshow(colored)
    ax.set_title(
    f"Image C: Filtered Components (Size $\\geq {size_thresh}$)\n",
    pad=15,
    )
    ax.axis("off")

    for lab, p in props.items():
        xc, yc = p["centroid"]
        min_x, min_y, max_x, max_y = p["bbox"]
        theta = p["orientation"]

        rect = patches.Rectangle(
            (min_x, min_y),
            max_x - min_x,
            max_y - min_y,
            linewidth=1.2,
            edgecolor="cyan",
            facecolor="none",
            linestyle="--",
            alpha=0.9,
        )
        ax.add_patch(rect)

        axis_len = 30
        x1 = xc + axis_len * np.cos(theta)
        y1 = yc + axis_len * np.sin(theta)
        x2 = xc - axis_len * np.cos(theta)
        y2 = yc - axis_len * np.sin(theta)
        ax.plot([x1, x2], [y1, y2], color="yellow", linewidth=1.5, alpha=0.9)

        x3 = xc + (axis_len * 0.6) * np.cos(theta + np.pi / 2)
        y3 = yc + (axis_len * 0.6) * np.sin(theta + np.pi / 2)
        x4 = xc - (axis_len * 0.6) * np.cos(theta + np.pi / 2)
        y4 = yc - (axis_len * 0.6) * np.sin(theta + np.pi / 2)
        ax.plot([x3, x4], [y3, y4], color="red", linewidth=1.5, alpha=0.9)

        ax.text(
            xc,
            yc,
            str(lab),
            color="white",
            fontsize=8,
            fontweight="bold",
            ha="center",
            va="center",
            bbox=dict(facecolor="black", alpha=0.6, pad=1),
        )

    legend_elements = [
        plt.Line2D([0], [0], color="yellow", lw=2, label="Major Axis"),
        plt.Line2D([0], [0], color="red", lw=2, label="Minor Axis"),
    ]
    ax.legend(handles=legend_elements, loc="upper right", fontsize=8, framealpha=0.8)

    outfile = f"Image_C_Size_{size_thresh}.png"
    plt.tight_layout()
    plt.savefig(outfile, bbox_inches="tight", dpi=600, facecolor="#fdf6e3")
    plt.close()
    print(f"[Saved] {outfile}")


if __name__ == "__main__":
    print("Starting\n")

    original_img, binary_mask = load_and_preprocess("comb.img")
    plt.imsave("Image_B_Original.png", original_img, cmap="gray")
    plt.imsave("Image_BT_Binary.png", binary_mask, cmap="gray")

    raw_labels = label_components(binary_mask)
    global_colors = generate_color_map(raw_labels)

    size_filters = [100, 500, 1000]

    for size in size_filters:
        clean_labels, mapping = filter_and_relabel(raw_labels, size)
        features = extract_features(clean_labels)

        save_component_description_table(features, size)

        visualize_results(clean_labels, features, size, global_colors, mapping)

    print("Ended")

\end{lstlisting}

\end{document}